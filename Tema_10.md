# Тема 10. Декораторы и исключения
Отчет по Теме #10 выполнил:
- Иванов Игорь Олегович
- ПИЭ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ |---------|---------|
| Задание 1 | +       | +       |
| Задание 2 | +       | +       |
| Задание 3 | +       | +       |
| Задание 4 | +       | +       |
| Задание 5 | +       | +       |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Наверняка вы думаете, что декораторы – это какая-то бесполезная
### вещь, которая вам никогда не пригодится, но тут вдруг на паре по
### математике преподаватель просит всех посчитать число Фибоначчи для
### 100. Кто-то будет считать вручную (так точно не нужно), кто-то
### посчитает на калькуляторе, а кто-то подумает, что он самый крутой и
### напишет рекурсивную программу на Python и немного огорчится,
### потому что данная программа будет достаточно долго считаться, если
### ее просто так запускать. Но именно тут к вам на помощь приходят
### декораторы, например @lru_cache (он предназначен для решения задач
### динамическим программированием, если простыми словами, то этот
### декоратор запоминает промежуточные результаты и при рекурсивном
### вызове функции программа не будет считать одни и те же значения, а
### просто “возьмёт их из этого декоратора”). Вам нужно написать
### программу, которая будет считать числа Фибоначчи для 100 и
### запустить ее без этого декоратора и с ним, посмотреть на разницу во
### времени решения поставленной задачи.
### P.S. при запуске без декоратора можете долго не ждать, для
### наглядности хватит 10 секунд ожидания.

```python
from functools import lru_cache


@lru_cache(None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(100))
```
### Результат.

![Меню](https://github.com/ANARKI-MOOZ/SoftwareEngineering/blob/Тема_10/pic/lab1.png)

### Выводы

добавили декоратор

## Лабораторная работа №2
### Илья пишет свой сайт и ему необходимо сделать минимальную
### проверку ввода данных пользователя при регистрации. Для этого он
### реализовал функцию, которая выводит данные пользователя на экран и
### решил, что будет проверять правильность введённых данных при
### помощи декоратора, но в этом ему потребовалась ваша помощь.
### Напишите декоратор для функции, который будет принимать все
### параметры вызываемой функции (имя, возраст) и проверять чтобы
### возраст был больше 0 и меньше 130.
### Причем заметьте, что неважно сколько пользователь введет данных на
### сайт к Илье, будут обрабатываться только первые 2 аргумента.

```python
def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]

        if age < 0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)

    return output_func


@check
def personal_info(name, age):
    print(f"Name: {name} Age: {age}")

personal_info('Владимир', 38)
personal_info('Александр', -5)
personal_info('Петр', 138, 15, 48, 2)
```
### Результат.

![Меню](https://github.com/ANARKI-MOOZ/SoftwareEngineering/blob/Тема_10/pic/lab2.png)

### Выводы

добавили декоратор проверки

## Лабораторная работа №3
### Вам понравилась идея Ильи с сайтом, и вы решили дальше работать
### вместе с ним. Но вот в вашем проекте появилась проблема, кто-то
### пытается сломать вашу функцию с получением данных для сайта. Эта
### функция работает только с данными integer, а какой-то недохакер
### пытается все сломать и вместо нужного типа данных отправляет string.
### Воспользуйтесь исключениями, чтобы неподходящий тип данных не
### ломал ваш сайт.
### Также дополнительно можете обернуть весь код функции в
### try/except/finally для того, чтобы программа вас оповестила о том, что
### выявлена какая-то ошибка или программа успешно выполнена.

```python
def data(*args):
    try:
        for i in range(len(*args)):
            try:
                result = (args[0][i] * 15) // 10
                print(result)
            except Exception as ex:
                print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')

data([1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45])
```
### Результат.

![Меню](https://github.com/ANARKI-MOOZ/SoftwareEngineering/blob/Тема_10/pic/lab3.png)

### Выводы

применили try, чтобы обработать исключения
  
## Лабораторная работа №4
### Продолжая работу над сайтом, вы решили написать собственное
### исключение, которое будет вызываться в случае, если в функцию
### проверки имени при регистрации передана строка длиннее десяти
### символов, а если имя имеет допустимую длину, то в консоль
### выводиться “Успешная регистрация”

```python
class NegativeValueException(Exception):
    pass

def check_name(name):
    if len(name) > 10:
        raise NegativeValueException('Длина более 10 символов')
    else:
        print('Успешная регистрация')

name = '123456788910'
check_name(name)
```
### Результат.

![Меню](https://github.com/ANARKI-MOOZ/SoftwareEngineering/blob/Тема_10/pic/lab4.png)

### Выводы

написали свое исключение

## Лабораторная работа №5
### После запуска сайта вы поняли, что вам необходимо добавить логгер,
### для отслеживания его работы. Готовыми вариантами вы не захотели
### пользоваться, и поэтому решили создать очень простую пародию. Для
### этого создали две функции: __init__() (вызывается при создании класса
### декоратора в программе) и __call__() (вызывается при вызове
### декоратора). Создайте необходимый вам декоратор. Выведите все логи
### в консоль.



```python
class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__ успешный запуск')
        self.func = func

    def __call__(self):
        print('> Проверка перед запуском', self.func.__name__)
        self.func()
        print('> Проверка безопасного выключения')


@SiteChecker
def site():
    print('Усердная работа сайта')

print('>> Сайт запущен')
site()
print('>> Сайт выключен')
```
### Результат.

![Меню](https://github.com/ANARKI-MOOZ/SoftwareEngineering/blob/Тема_10/pic/lab5.png)

### Выводы

написали свой декоратор

## Самостоятельная работа №1
### Вовочка решил заняться спортивным программированием на python, но
### для этого он должен знать за какое время выполняется его программа.
### Он решил, что для этого ему идеально подойдет декоратор для
### функции, который будет выяснять за какое время выполняется та или
### иная функция. Помогите Вовочке в его начинаниях и напишите такой
### декоратор.
### Подсказка: необходимо использовать модуль time
### Декоратор необходимо использовать для этой функции:
### def fibonacci():                                      
###    fib1 = fib2 = 1
###    for i in range(2, 200):
###        fib1, fib2 = fib2, fib1 + fib2
### print(fib2, end=' ')
### if \_\_name__ == '\_\_main__':
###    fibonacci()
### Результатом вашей работы будет листинг кода и скриншот консоли, в
### котором будет выполненная функция Фибоначчи и время выполнения
### программы.
### Также на этом примере можете посмотреть, что решение задач через
### рекурсию не всегда является хорошей идеей. Поскольку решение
### Фибоначчи для 100 с использованием рекурсии и без динамического
### программирования решается более десяти секунд, а решение точно
### такой же задачи, но через цикл for еще и для 200, занимает меньше 1
### секунды.

```python
import time

def measure_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"Время выполнения функции: {end_time - start_time:.6f} секунд")
        return result
    return wrapper

@measure_time
def fibonacci():
    fib1 = fib2 = 1
    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end=' ')
    print()

fibonacci()
```
### Результат.

![Меню]()

### Выводы

1. `start_time = time.time()` Время начала выполнения
2. `result = func(*args, **kwargs)` Выполнение функции
3. `end_time = time.time()` Время окончания выполнения
  
## Самостоятельная работа №2
### Посмотрев на Вовочку, вы также загорелись идеей спортивного
### программирования, начав тренировки вы узнали, что для решения
### некоторых задач необходимо считывать данные из файлов. Но через
### некоторое время вы столкнулись с проблемой что файлы бывают
### пустыми, и вы не получаете вводные данные для решения задачи.
### После этого вы решили не просто считывать данные из файла, а всю
### конструкцию оборачивать в исключения, чтобы избежать такой    проблемы. Создайте пустой файл и файл, в котором есть какая-то
### информация. Напишите код программы. Если файл пустой, то, нужно
### вызвать исключение (“бросить исключение”) и вывести в консоль
### “файл пустой”, а если он не пустой, то вывести информацию из файла.

```python
def read_file(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            content = file.read()
            if not content:
                raise ValueError("файл пустой")
            print("Содержимое файла:")
            print(content)
    except ValueError as e:
        print(e)
    except FileNotFoundError:
        print("Файл не найден")

read_file("pusto.txt")
read_file("nepusto.txt")
```
### Результат.

![Меню]()

### Выводы

`if not content:` Проверяем, пуст ли файл
  
## Самостоятельная работа №3
### Напишите функцию, которая будет складывать 2 и введенное
### пользователем число, но если пользователь введет строку или другой
### неподходящий тип данных, то в консоль выведется ошибка
### “Неподходящий тип данных. Ожидалось число.”. Реализовать
### функционал программы необходимо через try/except и подобрать
### правильный тип исключения. Создавать собственное исключение
### нельзя. Проведите несколько тестов, в которых исключение вызывается
### и нет. Результатом выполнения задачи будет листинг кода и
### получившийся вывод в консоль


```python
def add_two_to_input():
    try:
        user_input = input("Введите число: ")
        number = float(user_input)
        result = 2 + number
        print(f"Результат сложения: {result}")
    except ValueError:
        print("Неподходящий тип данных")

add_two_to_input()

add_two_to_input()
```
### Результат.

![Меню]()

### Выводы

`number = float(user_input)` Пробуем преобразовать ввод в число
`except ValueError:` Обработка исключения, если преобразование в число невозможно

  
## Самостоятельная работа №4
### Создайте собственный декоратор, который будет использоваться для
### двух любых вами придуманных функций. Декораторы, которые
### использовались ранее в работе нельзя воссоздавать. Результатом
### выполнения задачи будет: класс декоратора, две как-то связанными с
### ним функциями, скриншот консоли с выполненной программой и
### подробные комментарии, которые будут описывать работу вашего
### кода.


```python
class RepeatDecorator:
    def __init__(self, times):
        self.times = times

    def __call__(self, func):
        def wrapper(*args, **kwargs):
            for i in range(self.times):
                print(f"Студент {i + 1} из {self.times}")
                func(*args, **kwargs)
        return wrapper

@RepeatDecorator(times=3)
def print_hello():
    print("Здравствуйте, Преподаватель")

counter = 0

@RepeatDecorator(times=5)
def increment_counter():
    global counter
    counter += 1
    print(f"Текущее значение счетчика: {counter}")

print("Запуск функции print_hello:")
print_hello()

print("\nЗапуск функции increment_counter:")
increment_counter()
```
### Результат.

![Меню]()

### Выводы

1. `class RepeatDecorator:` Декоратор, который повторяет выполнение функции заданное количество раз
2. `def print_hello():` Функция для печати приветствия
3. `def increment_counter():` Функция для увеличения счетчика
  
## Самостоятельная работа №5
### Создайте собственное исключение, которое будет использоваться в
### двух любых фрагментах кода. Исключения, которые использовались
### ранее в работе нельзя воссоздавать. Результатом выполнения задачи
### будет: класс исключения, код к котором в двух местах используется это
### исключение, скриншот консоли с выполненной программой и
### подробные комментарии, которые будут описывать работу вашего
### кода.


```python
class ZeroError(Exception):
    def __init__(self, message="Скажем нет действиям на ноль"):
        super().__init__(message)

import math

def DivisionByZero(value):
    if value == 0:
        raise ZeroError("Ошибка: Действие на ноль вызвало сильную реакцию.")
    return value

def MultiplicationByZero(a, b):
    result = a * b
    if result == 0:
        raise ZeroError("Ошибка: Действие на ноль вызвало сильную реакцию.")
    return result

try:
    print("Деление 10 на 5:")
    print(DivisionByZero(10/5))

    print("\nДеление 0 на 10:")
    print(DivisionByZero(0/10))

except ZeroError as e:
    print(e)

print("\n---\n")

try:
    print("Умножение 10 на 5:")
    print(MultiplicationByZero(10, 5))

    print("\nУмножение 0 на 100:")
    print(MultiplicationByZero(0, 100))

except ZeroError as e:
    print(e)
```

### Результат.

![Меню]()

### Выводы

1. `class ZeroError(Exception):` Создаем собственное исключение
2. `def MultiplicationByZero(a, b):` Функция для вычисления деления с нулём
3. `def MultiplicationByZero(a, b):` Функция для вычисления умножения двух чисел

## Общие выводы по теме
Базово освоил работу с исключениями и декораторами
